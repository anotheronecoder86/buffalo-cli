package destroy

import (
	"bytes"
	"context"
	"flag"
	"fmt"
	"io"
	"strings"
	"text/tabwriter"

	"github.com/gobuffalo/cli/cmd/cli/help"
	"github.com/gobuffalo/cli/cmd/cli/plugin"
)

// Command instance to be imported outside of this package.
var Command = &command{
	flagSet: flag.NewFlagSet("destroy", flag.ContinueOnError),
}

type command struct {
	yesToAll bool
	flagSet  *flag.FlagSet

	destroyers Destroyers
}

func (c command) Name() string {
	return "destroy"
}

func (c command) Aliases() []string {
	return []string{"d"}
}

func (c command) HelpText() string {
	return "Destroys files generated by Buffalo"
}

func (c *command) LongHelpText() string {
	if len(c.destroyers) == 0 {
		return "No destroyers registered.\n"
	}

	buf := bytes.NewBuffer([]byte{})
	w := tabwriter.NewWriter(buf, 0, 0, 3, ' ', 0)

	w.Write([]byte("Registered Destroyers\n"))
	for _, gg := range c.destroyers {
		aliases := []string{}
		if gh, ok := gg.(plugin.Aliaser); ok {
			aliases = gh.Aliases()
		}

		htext := fmt.Sprintf("runs the %v destroy", gg.Name())
		if gh, ok := gg.(help.HelpTexter); ok {
			htext = gh.HelpText()
		}

		fmt.Fprintf(w, "%s\t%+v\t%s\n", gg.Name(), strings.Join(aliases, ", "), htext)
	}

	w.Write([]byte("\n"))

	w.Flush()

	return buf.String()
}

func (g *command) Help(ctx context.Context, args []string) error {
	if len(args) < 1 {
		fmt.Printf(g.LongHelpText())

		return nil
	}

	// Find the generator
	// Print its help text
	gg := g.destroyers.Find(args[0])
	if gg == nil {
		fmt.Printf("Error: No destroyer found for '%v'\n\n", args[0])
		fmt.Printf(g.LongHelpText())

		return nil
	}

	usage := "buffalo destroy " + gg.Name()
	if hh, ok := gg.(help.Usager); ok {
		usage = hh.Usage()
	}

	fmt.Printf("Usage: %v\n\n", usage)

	htext := fmt.Sprintf("runs the %v destroy\n", gg.Name())
	if gh, ok := gg.(help.HelpTexter); ok {
		htext = gh.HelpText() + "\n"
	}

	fmt.Printf(htext)

	if ht, ok := gg.(help.LongHelpTexter); ok {
		fmt.Printf(ht.LongHelpText())
	}

	return nil
}

func (c command) Usage() string {
	return "buffalo destroy [flags] [destroyer] [name]"
}

func (c *command) ParseFlags(args []string) (*flag.FlagSet, error) {
	if c.flagSet == nil {
		c.flagSet = flag.NewFlagSet("destroy", flag.ContinueOnError)
		c.flagSet.Usage = func() {}
		c.flagSet.SetOutput(io.Discard)
	}

	c.flagSet.BoolVar(&c.yesToAll, "y", false, "Pre-confirm all prompts")
	_ = c.flagSet.Parse(args)

	if c.yesToAll {
		for _, dd := range c.destroyers {
			dd.PreConfirm()
		}
	}

	return c.flagSet, nil
}

func (c *command) Receive(pls plugin.Plugins) {
	for _, pp := range pls {
		if dd, ok := pp.(Destroyer); ok {
			c.destroyers = append(c.destroyers, dd)
		}
	}
}

func (c *command) Main(ctx context.Context, pwd string, args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("you need to provide a valid destroyer name in order to invoke it")
	}

	dd := c.destroyers.Find(args[0])
	if dd == nil {
		return fmt.Errorf("could not find a destroyer named %s", args[0])
	}

	return dd.Destroy(ctx, pwd, args[1:])
}
